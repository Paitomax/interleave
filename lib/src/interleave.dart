/// Interleave build method for getting a item from index
typedef InterleaveItemBuilder<T> = T Function(
  int interleaveIndex,
  int listIndex,
);

/// Interleave class for generating a interleaved list
class Interleave<T> {
  /// Steps to interleaving items.
  final int step;

  /// Offset to start interleaving item.
  final int offset;

  /// Items quantity.
  final int itemLength;

  /// Interleaving items quantity.
  final int interleavingItemLength;

  /// The builder for the items.
  final InterleaveItemBuilder<T> itemBuilder;

  /// The builder for interleaving item.
  final InterleaveItemBuilder<T> interleavingItemBuilder;

  /// Total items length (items + interleaving items)
  int get length => itemLength + interleavingItemLength;

  /// Interleaving item max index
  int get _maxInterleavingItemIndex =>
      interleavingItemLength * step - step + offset;

  /// Interleaving items quantity that can be showed interleaving with items
  int get _maxInterleavingItems =>
      ((itemLength) / step).truncate() + 1 - offset;

  /// Items quantity (items + interleavingItems) that can be showed interleaving
  int get _maxItemsInterleaved => itemLength + _maxInterleavingItems;

  /// Interleave default constructor
  const Interleave({
    required int step,
    int? offset,
    required this.itemLength,
    required this.interleavingItemLength,
    required this.itemBuilder,
    required this.interleavingItemBuilder,
  })  : step = step + 1,
        offset = offset ?? step,
        assert(step > 0, 'step must be greater than 0'),
        assert((offset ?? 0) >= 0, 'offset must be greater than or equal to 0'),
        assert(
            itemLength >= 0, 'itemLength must be greater than or equal to 0'),
        assert(interleavingItemLength >= 0,
            'interleavingItemLength must be greater than or equal to 0'),
        assert(itemLength > 0 || interleavingItemLength > 0,
            'itemLength or interleavingItemLength must be greater than 0');

  /// Generate interleaved list from two lists
  static List<T> generateFromList<T>({
    required int step,
    required List<T> itemList,
    required List<T> interleavingList,
    int? offset,
    bool growable = true,
  }) =>
      Interleave(
        step: step,
        offset: offset,
        itemLength: itemList.length,
        interleavingItemLength: interleavingList.length,
        itemBuilder: (interleaveIndex, listIndex) => itemList[interleaveIndex],
        interleavingItemBuilder: (interleaveIndex, listIndex) =>
            interleavingList[interleaveIndex],
      ).generate(growable: growable);

  /// Generate interleaved list from builders
  static List<T> generateFromBuilder<T>({
    required int step,
    int? offset,
    required int itemLength,
    required int interleavingItemLength,
    required InterleaveItemBuilder<T> itemBuilder,
    required InterleaveItemBuilder<T> interleavingItemBuilder,
    bool growable = true,
  }) =>
      Interleave(
        step: step,
        offset: offset,
        itemLength: itemLength,
        interleavingItemLength: interleavingItemLength,
        itemBuilder: itemBuilder,
        interleavingItemBuilder: interleavingItemBuilder,
      ).generate(growable: growable);

  /// Get item from interleaved list generated by two lists
  static T itemFromList<T>({
    required int step,
    required List<T> itemList,
    required List<T> interleavingList,
    required int index,
    int? offset,
  }) =>
      Interleave(
        step: step,
        offset: offset,
        itemLength: itemList.length,
        interleavingItemLength: interleavingList.length,
        itemBuilder: (interleaveIndex, listIndex) => itemList[interleaveIndex],
        interleavingItemBuilder: (interleaveIndex, listIndex) =>
            interleavingList[interleaveIndex],
      ).item(index);

  /// Get item from interleaved list through builder
  static T itemFromBuilder<T>({
    required int step,
    int? offset,
    required int itemLength,
    required int interleavingItemLength,
    required InterleaveItemBuilder<T> itemBuilder,
    required InterleaveItemBuilder<T> interleavingItemBuilder,
    required int index,
  }) =>
      Interleave(
        step: step,
        offset: offset,
        itemLength: itemLength,
        interleavingItemLength: interleavingItemLength,
        itemBuilder: itemBuilder,
        interleavingItemBuilder: interleavingItemBuilder,
      ).item(index);

  /// Generate interleaved list
  List<T> generate({bool growable = true}) {
    return List.generate(
      length,
      (index) => item(index),
      growable: growable,
    );
  }

  /// Get item from index of a interleaved list
  T item(int index) {
    if (index >= length || index < 0) {
      throw RangeError.range(index, 0, length - 1);
    }

    final isOffset = index < offset;
    final shouldOffset = isOffset && index < itemLength;

    // If index is less than offset, then needs to build item
    if (shouldOffset) {
      return itemBuilder(index, index);
    }

    // should return offset item but index is greater than item length
    final cantOffset = isOffset && !shouldOffset;

    final isInterleavingItemIndex = (index - offset) % step == 0 || cantOffset;

    var interleavingItemIndex = ((index - offset) / step).truncate();
    var itemIndex = index - (interleavingItemIndex + 1);

    final canShowItem = itemIndex < itemLength;
    final canShowInterleavingItem =
        interleavingItemIndex < interleavingItemLength;

    final shouldShowInterleavingItem =
        (canShowInterleavingItem && isInterleavingItemIndex) || !canShowItem;

    if (shouldShowInterleavingItem) {
      /// Verify that should be show item and if already showed all of them
      if (!isInterleavingItemIndex || !canShowItem) {
        /// Adjust interleaving item index case all items already had been showed
        interleavingItemIndex =
            _maxInterleavingItems + (index - _maxItemsInterleaved);
      }

      /// Return interleaving item
      return interleavingItemBuilder(interleavingItemIndex, index);
    }

    /// Verify if [index] is greater than [_maxInterleavingItemIndex]
    if (index > _maxInterleavingItemIndex) {
      /// Diff between [index] with last showed [interleavingItemIndex]
      final indexDiff = index - (_maxInterleavingItemIndex);

      /// Interleaving items quantity that has not been showed
      final bannerMissed = (indexDiff / step).truncate();

      /// Adjust [itemIndex] case has already showed all interleaving items
      itemIndex = itemIndex + bannerMissed;
    }

    /// Return item
    return itemBuilder(itemIndex, index);
  }
}
